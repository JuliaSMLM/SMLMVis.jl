var documenterSearchIndex = {"docs":
[{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"CurrentModule = SMLMVis.MIC\nDocTestSetup = quote\n    using SMLMVis\nend","category":"page"},{"location":"mic/#SMLMVis.MIC","page":"MP4 Generation","title":"SMLMVis.MIC","text":"","category":"section"},{"location":"mic/#Overview","page":"MP4 Generation","title":"Overview","text":"","category":"section"},{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"MIC","category":"page"},{"location":"mic/#SMLMVis.MIC","page":"MP4 Generation","title":"SMLMVis.MIC","text":"Tools and utilities for the visualization of data collected via the      MATLAB Instrument Control Toolbox.\n\n\n\n\n\n","category":"module"},{"location":"mic/#Basic-Usage","page":"MP4 Generation","title":"Basic Usage","text":"","category":"section"},{"location":"mic/#Process-one-file-using-several-keyword-options","page":"MP4 Generation","title":"Process one file using several keyword options","text":"","category":"section"},{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"using SMLMVis\n\ndirname = \"C:/Data\"\nfilename = \"CellMovie\"\nfn = joinpath(dirname, filename * \".h5\")\n\nmic2mp4(fn; fps = 20, percentilerange = 0.99, zoom = 4, frame_range = 1:100)\n","category":"page"},{"location":"mic/#Process-a-directory","page":"MP4 Generation","title":"Process a directory","text":"","category":"section"},{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"using SMLMVis\n\ndirname = \"C:/Data\"\n\n# A little julia ...\nfiles = filter(f -> endswith(f, \".h5\"), readdir(dirname))\nfullpathfiles = dirname .* \"/\" .* files\n\n# Use broadcasting over the file names\nmic2mp4.(fullpathfiles; fps = 20, percentilerange = 0.99)","category":"page"},{"location":"mic/#The-first-50-frames-in-all-datasets","page":"MP4 Generation","title":"The first 50 frames in all datasets","text":"","category":"section"},{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"using SMLMVis\n\ndirname = \"C:/Data\"\nsavedir = \"C:/Data/Results\"\nfilename = \"CellMovie\"\nfn = joinpath(dirname, filename * \".h5\")\n\n# Use comprehension over datasets and put results a different folder\nn = SMLMVis.MIC.count_datasets(fn)\n[mic2mp4(fn; savedir=savedir, fps=20, percentilerange=0.99, datasetnum=i, frame_range=1:50) for i in 1:n];","category":"page"},{"location":"mic/#API","page":"MP4 Generation","title":"API","text":"","category":"section"},{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"Modules = [MIC]","category":"page"},{"location":"mic/","page":"MP4 Generation","title":"MP4 Generation","text":"Modules = [MIC]","category":"page"},{"location":"mic/#SMLMVis.MIC.count_datasets-Tuple{AbstractString}","page":"MP4 Generation","title":"SMLMVis.MIC.count_datasets","text":"count_datasets(filename::AbstractString; groupname::AbstractString=\"Channel01/Zposition001\")\n\nCount the number of datasets in an HDF5 file.\n\nArguments\n\nfilename::AbstractString: The name of the HDF5 file to count datasets in.\ngroupname::AbstractString: The name of the group to count datasets in. Default is \"Channel01/Zposition001\".\n\nReturns\n\nn_datasets::Int: The number of datasets in the specified group.\n\n\n\n\n\n","category":"method"},{"location":"mic/#SMLMVis.MIC.isMIC-Tuple{AbstractString}","page":"MP4 Generation","title":"SMLMVis.MIC.isMIC","text":"isMIC(filename::AbstractString)\n\nCheck if an HDF5 file has the expected group structure for a MIC file.\n\nArguments\n\nfilename::AbstractString: The name of the HDF5 file to check.\n\nReturns\n\nout::Bool: true if the file has the expected group structure, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"mic/#SMLMVis.MIC.isTIRF-Tuple{AbstractString}","page":"MP4 Generation","title":"SMLMVis.MIC.isTIRF","text":"isTIRF(filename::AbstractString)\n\nCheck if the given HDF5 file contains TIRF (Total Internal Reflection Fluorescence) data.\n\nArguments\n\nfilename::AbstractString: The path to the HDF5 file to check.\n\nReturns\n\nBool: Returns true if the file contains TIRF data, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"mic/#SMLMVis.MIC.mic2mp4-Tuple{AbstractString}","page":"MP4 Generation","title":"SMLMVis.MIC.mic2mp4","text":"mic2mp4(filename::AbstractString;\n    savefilename::Union{Nothing,AbstractString}=nothing,\n    groupname::AbstractString=\"Channel01/Zposition001\",\n    datasetnum::Int=1,\n    framenormalize::Bool=false,\n    fps::Int=30,\n    crf::Int=23,\n    percentilerange::Union{Real,Nothing}=nothing,\n    zoom::Int=1,\n    frame_range::Union{AbstractRange, Nothing}=nothing)\n\nConvert a MIC HDF5 file to an MP4 video.\n\nThis function converts a MIC HDF5 file to an MP4 video using the specified group, dataset number,      frames per second, and constant rate factor. The output video is saved to the specified output file,      or named after the input file if no output file is specified. If framenormalize is true,      each frame of the dataset is normalized individually. The function returns nothing.\n\nArguments\n\nfilename::AbstractString: The name of the HDF5 file to convert.\nsavefilename::Union{Nothing,AbstractString}: The name of the output MP4 file. If nothing, the output file is named after the input file. Default is nothing.\nsavedir::Union{Nothing,AbstractString}: The output directory. If nothing path is the same as the input file. Default is nothing.\ngroupname::AbstractString: The name of the group to convert. Default is \"Channel01/Zposition001\".\ndatasetnum::Int: The number of the dataset to convert. Default is 1.\nframenormalize::Bool: Whether to normalize each frame of the dataset individually. Default is false.\nfps::Int: The frames per second of the output video. Default is 30.\ncrf::Int: The constant rate factor of the output video. Default is 10.\npercentilerange::Union{Real,Nothing}=nothing: The percentile range to use for normalization. If nothing, the full range of arr is used.\nzoom::Int: The zoom factor to apply to each frame. Default is 1.\nframe_range::Union{AbstractRange, Nothing}=nothing: The range of frames to use for the video. If nothing, all frames are used.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"mic/#SMLMVis.MIC.normalize!-Tuple{AbstractArray{<:Real}}","page":"MP4 Generation","title":"SMLMVis.MIC.normalize!","text":"normalize!(arr::AbstractArray{<:Real}; minval::Union{Real,Nothing}=nothing, maxval::Union{Real,Nothing}=nothing, percentilerange::Union{Real,Nothing}=nothing)\n\nNormalize the input array arr in place. The normalization is done based on the minimum and maximum values of the array, or based on a percentile range if percentilerange is provided.\n\nArguments\n\narr::AbstractArray{<:Real}: The array to be normalized.\nminval::Union{Real,Nothing}=nothing: The minimum value to use for normalization. If nothing, the minimum value of arr is used.\nmaxval::Union{Real,Nothing}=nothing: The maximum value to use for normalization. If nothing, the maximum value of arr is used.\npercentilerange::Union{Real,Nothing}=nothing: The percentile range to use for normalization. If nothing, the full range of arr is used.\n\nReturns\n\nnothing: The function modifies arr in place and does not return anything.\n\n\n\n\n\n","category":"method"},{"location":"mic/#SMLMVis.MIC.readMIC-Tuple{AbstractString}","page":"MP4 Generation","title":"SMLMVis.MIC.readMIC","text":"readMIC(filename::AbstractString;\n    groupname::AbstractString=\"Channel01/Zposition001\",\n    datasetnum::Int=1)\n\nRead data from a MIC HDF5 file.\n\nArguments\n\nfilename::AbstractString: The name of the HDF5 file to read data from.\ngroupname::AbstractString: The name of the group to read data from. Default is \"Channel01/Zposition001\".\ndatasetnum::Int: The number of the dataset to read. Default is 1.\n\nReturns\n\ndata::Array: The data read from the specified dataset.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"CurrentModule = SMLMVis.GaussRender\nDocTestSetup = quote\n    using SMLMVis\nend","category":"page"},{"location":"blob_rendering/#SMLMVis.GaussRender","page":"Blob Rendering","title":"SMLMVis.GaussRender","text":"","category":"section"},{"location":"blob_rendering/#Overview","page":"Blob Rendering","title":"Overview","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"GaussRender","category":"page"},{"location":"blob_rendering/#SMLMVis.GaussRender","page":"Blob Rendering","title":"SMLMVis.GaussRender","text":"module GaussRender\n\nMethods for rendering Gaussian blobs into images.\n\nThe primary exported function is the render_blobs function, which takes a SMLMData.SMLD structure and renders it into an image. The image is returned as a ColorTypes.RGB{Float32} array.\n\nThis can be saved as a PNG file using the save function from the Images package.\n\n\n\n\n\n","category":"module"},{"location":"blob_rendering/#Basic-Usage","page":"Blob Rendering","title":"Basic Usage","text":"","category":"section"},{"location":"blob_rendering/#Rendering-2D-SMLM-Images","page":"Blob Rendering","title":"Rendering 2D SMLM Images","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"2D SMLM images will render with the hot colormap by default.  ","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"using SMLMVis\nusing SMLMSim\nusing Images\n\nsmld_true, smld_model, smld_noisy = SMLMSim.sim(;\n    ρ=10,\n    σ_PSF=0.13,  \n    minphotons=50,\n    ndatasets=10,\n    nframes=1000,\n    framerate=50.0, \n    pattern=SMLMSim.Nmer2D(),\n    molecule=SMLMSim.GenericFluor(; q=[0 50; 1e-2 0]), #1/s \n    camera=SMLMSim.IdealCamera(; ypixels=32, xpixels=64, pixelsize=0.1)\n    ) \n\nout, = render_blobs(smld_noisy; zoom = 20)\nsave(\"nmer2d.png\", out) # hide","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"<img src=\"nmer2d.png\" alt=\"nmer2d.png\" width=\"600\"/>","category":"page"},{"location":"blob_rendering/#Rendering-3D-Images","page":"Blob Rendering","title":"Rendering 3D Images","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"3D SMLM images will render with a rainbow colormap by default. ","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"using SMLMVis\nusing SMLMSim\nusing Images\n\nsmld_true, smld_model, smld_noisy = SMLMSim.sim(;\n    ρ=10,\n    σ_PSF=[0.13, 0.13, 0.3],  \n    minphotons=50,\n    ndatasets=10,\n    nframes=1000,\n    framerate=50.0, \n    pattern=SMLMSim.Nmer3D(),\n    molecule=SMLMSim.GenericFluor(; q=[0 50; 1e-2 0]), #1/s \n    camera=SMLMSim.IdealCamera(; ypixels=32, xpixels=64, pixelsize=0.1)\n    ) \n\nout, = render_blobs(smld_noisy; zoom = 20)\nsave(\"nmer3d.png\", out) # hide","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"<img src=\"nmer3d.png\" alt=\"nmer3d.png\" width=\"600\"/>","category":"page"},{"location":"blob_rendering/#API","page":"Blob Rendering","title":"API","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"Modules = [GaussRender]","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"Modules = [GaussRender]","category":"page"},{"location":"blob_rendering/#SMLMVis.GaussRender.add_blob!-Tuple{AbstractArray{<:Real}, SMLMVis.GaussRender.ImagePatch2D, Int64, Int64}","page":"Blob Rendering","title":"SMLMVis.GaussRender.add_blob!","text":"add_blob!(image, patch, offset_x, offset_y)\n\nAdd a single blob to an image patch at the specified offset.\n\nArguments\n\n- `image::AbstractArray{<:Real}` : The image patch to which the blob will be added.\n- `patch::ImagePatch2D`          : The blob to be added to the image.\n- `offset_x::Int`                : The x-offset for the blob.\n- `offset_y::Int`                : The y-offset for the blob.\n\nReturns\n\nThe image patch with the added blob.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.add_blob!-Tuple{SMLMVis.GaussRender.ImagePatch2D, SMLMVis.GaussRender.ImagePatch2D}","page":"Blob Rendering","title":"SMLMVis.GaussRender.add_blob!","text":"add_blob!(image, patch)\n\nArguments\n\nimage::ImagePatch2D : The image patch to which the blob will be added.\npatch::ImagePatch2D : The blob to be added to the image.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.add_blobs!-Union{Tuple{T}, Tuple{SMLMVis.GaussRender.ImagePatch2D{T}, Array{SMLMVis.GaussRender.ImagePatch2D{T}, 1}}} where T<:Real","page":"Blob Rendering","title":"SMLMVis.GaussRender.add_blobs!","text":"add_blobs!(image, patches)\n\nAdd multiple blobs to an image patch. \n\nArguments\n\n- `image::ImagePatch2D` : The image patch to which the blobs will be added.\n- `patches::Vector{ImagePatch2D}` : A vector of image patches to be added to the image.\n\nReturns\n\n- The image patch with the added blobs.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.add_blobs!-Union{Tuple{T}, Tuple{SMLMVis.GaussRender.ImagePatch3D{T}, Array{SMLMVis.GaussRender.ImagePatch2D{T}, 1}, ColorSchemes.ColorScheme, Tuple{Real, Real}}} where T<:Real","page":"Blob Rendering","title":"SMLMVis.GaussRender.add_blobs!","text":"add_blobs!(image, patches, cmap, z_range)\n\nArguments\n\n- `image::ImagePatch3D` : The 3D image patch to which the blobs will be added.\n- `patches::Vector{ImagePatch2D}` : A vector of 2D image patches to be added to the image.\n- `cmap::ColorScheme` : The colormap to be applied to the blobs.\n- `z_range::Tuple{Real,Real}` : The range of z-values for the colormap.\n\nReturns\n\n- Images added to patches are added to the image at the corresponding z-index based on the z-value of the patch.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.apply_colormap_to_image-Tuple{SMLMVis.GaussRender.ImagePatch2D, Any, Any}","page":"Blob Rendering","title":"SMLMVis.GaussRender.apply_colormap_to_image","text":"apply_colormap_to_image(gray_image::ImagePatch2D, cmap, percentile_cutoff)\n\nApplies a colormap to a 2D grayscale image patch after clamping its intensity values.\n\nClamps the intensity values of the grayscale image patch based on the specified percentile cutoff, and then applies the given colormap.\n\nArguments\n\n- `gray_image::ImagePatch2D`            : The input 2D grayscale image patch.\n- `cmap`                                : The colormap to be applied.\n- `percentile_cutoff`                   : The percentile cutoff for intensity clamping.\n\nReturns\n\n- An image with the colormap applied.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.apply_colormap_to_image-Tuple{SMLMVis.GaussRender.ImagePatch3D, ColorSchemes.ColorScheme, Any}","page":"Blob Rendering","title":"SMLMVis.GaussRender.apply_colormap_to_image","text":"apply_colormap_to_image(gray_image::ImagePatch3D, cmap::ColorScheme, percentile_cutoff)\n\nApply a colormap to a 3D grayscale image patch after clamping its intensity values.\n\nClamps the intensity values of each layer in the 3D grayscale image patch based on the specified percentile cutoff, and then applies the given colormap.  The final RGB image is constructed by accumulating the color values from each layer.\n\nArguments\n\ngray_image::ImagePatch3D            : The input 3D grayscale image patch.\ncmap::ColorScheme                   : The colormap to be applied.\npercentile_cutoff                   : The percentile cutoff for intensity clamping.\n\nReturns\n\nAn RGB image with the colormap applied.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.create_colormap-Tuple{Any, Any}","page":"Blob Rendering","title":"SMLMVis.GaussRender.create_colormap","text":"create_colormap(z, colormap)\n\nDetermine the best colormap to use based on the provided z and colormap parameters.\n\nIf both z and colormap are nothing, the function returns the 'hot' colormap. If z is provided and  colormap is nothing, the function returns the 'rainbowbgyr3585c72_n256' colormap. If colormap is provided,  it returns the specified colormap from ColorSchemes.\n\nArguments\n\nz                : A parameter that can influence the colormap selection.\ncolormap         : A string representing the desired colormap from ColorSchemes.\n\nReturns\n\nA colormap from ColorSchemes.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.gen_blob!-Tuple{SMLMVis.GaussRender.ImagePatch2D, Real, Real, Real, Real, Symbol}","page":"Blob Rendering","title":"SMLMVis.GaussRender.gen_blob!","text":"gen_blob!(patch, x, y, σ_x, σ_y, normalization; zoom=1)\n\nGenerate a 2D Gaussian blob centered at (x, y) with standard deviations σx and σy.    \n\nThe blob is normalized either by its integral or maximum value.\n\nArguments\n\n- `patch::ImagePatch2D` : The image patch to store the generated blob.\n- `x::Real`              : The x-coordinate of the blob center.\n- `y::Real`              : The y-coordinate of the blob center.\n- `σ_x::Real`            : The standard deviation of the blob along the x-axis.\n- `σ_y::Real`            : The standard deviation of the blob along the y-axis.\n- `normalization::Symbol`: The normalization method, either `:integral` or `:maximum`.\n- `zoom::Int`            : The zoom factor for the blob. Default is 1.\n\nReturns\n\n- The generated blob is stored in the `patch` argument.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.quantile_clamp!-Tuple{AbstractArray{<:Real}, Real}","page":"Blob Rendering","title":"SMLMVis.GaussRender.quantile_clamp!","text":"quantile_clamp!(im::AbstractArray{<:Real}, percentile_cutoff::Real)\n\nClamp the intensity values of an image based on the specified percentile cutoff.  \n\nArguments\n\nim::AbstractArray{<:Real} : The input image, a 2D array of real numbers.\npercentile_cutoff::Real   : The percentile cutoff for intensity clamping.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.render_blobs-Tuple{SMLMData.SMLD2D}","page":"Blob Rendering","title":"SMLMVis.GaussRender.render_blobs","text":"render_blobs(smld::SMLMData.SMLD2D; \nnormalization::Symbol=:integral,\nn_sigmas::Real=3,\ncolormap::Symbol=:hot\n)\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.render_blobs-Tuple{SMLMData.SMLD3D}","page":"Blob Rendering","title":"SMLMVis.GaussRender.render_blobs","text":"render_blobs(smld::SMLMData.SMLD3D; \nnormalization::Symbol=:integral,\nn_sigmas::Real=3,\ncolormap::Symbol=:rainbow_bgyr_35_85_c72_n256,\nz_range::Union{Nothing,Tuple{Real,Real}}=nothing\n)\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.render_blobs-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"Blob Rendering","title":"SMLMVis.GaussRender.render_blobs","text":"render_blobs(\nx_range::Tuple{Int,Int},\ny_range::Tuple{Int,Int},\nx::Vector{<:Real},\ny::Vector{<:Real},\nσ_x::Vector{<:Real},\nσ_y::Vector{<:Real};\nnormalization::Symbol=:integral,\nn_sigmas::Real=3,\ncolormap::Union{Nothing,Symbol}=nothing,\nz::Union{Nothing,Vector{<:Real}}=nothing,\nz_range::Union{Nothing,Tuple{Real,Real}}=nothing,\nzoom::Int=1,\npercentile_cutoff::Real=0.99\n)\n\nRender a stack of 2D Gaussian blobs as a single image.\n\nArguments\n\nx_range::Tuple{Int,Int}: The range of valid x-coordinates for the final image.\ny_range::Tuple{Int,Int}: The range of valid y-coordinates for the final image.\nx::Vector{<:Real}: A vector of x-coordinates for the centers of the Gaussian blobs.\ny::Vector{<:Real}: A vector of y-coordinates for the centers of the Gaussian blobs.\nσ_x::Vector{<:Real}: A vector of standard deviations for the Gaussian blobs in the x-direction.\nσ_y::Vector{<:Real}: A vector of standard deviations for the Gaussian blobs in the y-direction.\nnormalization::Symbol=:integral: The type of normalization to apply to the Gaussian blobs. Valid options are :integral (normalize the blobs so that their integrals are 1) and :maximum (normalize the blobs so that their maximum values are 1).\nn_sigmas::Real=3: The number of standard deviations to use for calculating the size of the region of interest (ROI) around each Gaussian blob.\ncolormap::Union{Nothing,Symbol}=nothing: The name of the colormap to use for colorizing the image. Valid options are :viridis, :plasma, :inferno, :magma, :cividis, :rainbow_bgyr_35_85_c72_n256, :hot, :cool, :spring, :summer, :autumn, :winter, :bone, :copper, :pink, :gray, :binary, :gist_earth, :terrain, :ocean, :jet, :nipy_spectral, :gist_ncar, :gist_rainbow, :hsv, :flag, :prism, :flag_r, :prism_r, :rainbow, :rainbow_r, :seismic, :seismic_r, :brg, :brg_r, :bwr, :bwr_r, :coolwarm, :coolwarm_r, :PiYG, :PiYG_r, :PRGn, :PRGn_r, :PuOr, :PuOr_r, :RdBu, :RdBu_r, :RdGy, :RdGy_r, :RdYlBu, :RdYlBu_r, :RdYlGn, :RdYlGn_r, :Spectral, :Spectral_r, :PuBu, :PuBu_r, :BuPu, :BuPu_r, :YlGn, :YlGn_r, :YlGnBu, :YlGnBu_r, :GnBu, :GnBu_r, :PuRd, :PuRd_r, :OrRd, :OrRd_r, :YlOrBr, :YlOrBr_r, :YlOrRd, :YlOrRd_r, :Reds, :Reds_r, :Greens, :Greens_r, :Blues, :Blues_r, :Purples, :Purples_r, :Oranges, :Oranges_r, :Greys, :Greys_r, :Pastel1, :Pastel1_r, :Pastel2, :Pastel2_r, :Set1, :Set1_r, :Set2, :Set2_r, :Set3, :Set3_r, :tab10, :tab10_r, :tab20, :tab20_r, :tab20b, :tab20b_r, :tab20c, :tab20c_r.\nz::Union{Nothing,Vector{<:Real}}=nothing: A vector of values to use for colorizing the image. If nothing, the image will be colorized based on intensity.\nz_range::Union{Nothing,Tuple{Real,Real}}=nothing: The range of values to use for colorizing the image. If nothing, the range will be determined automatically from the values in z.\nzoom::Int=1: The zoom factor to apply to the image. Must be an even integer\npercentile_cutoff::Real=0.99: The percentile cutoff for intensity scaling.\n\nReturns\n\nfinal_image, cmap, z_range: The rendered image as a 2D array of RGB values, colormap and z_range used for rendering. \n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SMLMVis","category":"page"},{"location":"#SMLMVis","page":"Home","title":"SMLMVis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SMLMVis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SMLMVis]","category":"page"},{"location":"#SMLMVis.arr2imgstack-Tuple{Array{<:Real, 3}}","page":"Home","title":"SMLMVis.arr2imgstack","text":"arr2imgstack(arr::Array{<:Real,3})\n\nConvert an array of 3D images to an array of arrays of type N0f8.\n\nArguments\n\narr::Array{<:Real,3}: The array of 3D images to convert.\nzoom::Int: The zoom factor to apply to each frame. Default is 1.\n\nReturns\n\nimgstack::Array{Array{Gray{N0f8},2}}\n\nThis function converts an 3D array to an array of matrices of type N0f8.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMVis.block_resample-Tuple{Array, Int64}","page":"Home","title":"SMLMVis.block_resample","text":"block_resample(array::Array, zoom::Int)\n\nResample an array by repeating each index a specified number of times. This function effectively increases the size of the array by a factor of zoom in each dimension.\n\nArguments\n\narray::Array: The array to be resampled.\nzoom::Int: The factor by which to increase the size of the array.\n\nReturns\n\nArray: The resampled array.\n\n\n\n\n\n","category":"method"},{"location":"#SMLMVis.save_to_mp4-Tuple{AbstractString, Array{<:Real, 3}}","page":"Home","title":"SMLMVis.save_to_mp4","text":"save_to_mp4(filename::AbstractString, arr::Array{<:Real,3};\n    fps::Int=30, crf::Int=23)\n\nSave an array of 3D images to an MP4 video.\n\nArguments\n\nfilename::AbstractString: The name of the output MP4 file.\narr::Array{<:Real,3}: The array of 3D images to save.\nfps::Int: The frames per second of the output video. Default is 30.\ncrf::Int: The constant rate factor of the output video. Default is 23.\nzoom::Int: The zoom factor to apply to each frame. Default is 1.\n\nReturns\n\nnothing\n\nThis function saves an array of 3D images to an MP4 video using the specified frames per second and constant rate factor. The output video is saved to the specified output file. The function returns nothing.\n\n\n\n\n\n","category":"method"}]
}
