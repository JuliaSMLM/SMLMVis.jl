var documenterSearchIndex = {"docs":
[{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"CurrentModule = SMLMVis.GaussRender\nDocTestSetup = quote\n    using SMLMVis\nend","category":"page"},{"location":"blob_rendering/#SMLMVis.GaussRender","page":"Blob Rendering","title":"SMLMVis.GaussRender","text":"","category":"section"},{"location":"blob_rendering/#Overview","page":"Blob Rendering","title":"Overview","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"GaussRender","category":"page"},{"location":"blob_rendering/#SMLMVis.GaussRender","page":"Blob Rendering","title":"SMLMVis.GaussRender","text":"module GaussRender\n\nMethods for rendering Gaussian blobs into images.\n\nThe primary exported function is the render_blobs function, which takes a SMLMData.SMLD structure and renders it into an image. The image is returned as a ColorTypes.RGB{Float32} array.\n\nThis can be saved as a PNG file using the save function from the Images package.\n\n\n\n\n\n","category":"module"},{"location":"blob_rendering/#Basic-Usage","page":"Blob Rendering","title":"Basic Usage","text":"","category":"section"},{"location":"blob_rendering/#Rendering-2D-SMLM-Images","page":"Blob Rendering","title":"Rendering 2D SMLM Images","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"2D SMLM images will render with the hot colormap by default.  ","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"using SMLMVis\nusing SMLMSim\nusing Images\n\nsmld_true, smld_model, smld_noisy = SMLMSim.sim(;\n    ρ=10,\n    σ_PSF=0.13,  \n    minphotons=50,\n    ndatasets=10,\n    nframes=1000,\n    framerate=50.0, \n    pattern=SMLMSim.Nmer2D(),\n    molecule=SMLMSim.GenericFluor(; q=[0 50; 1e-2 0]), #1/s \n    camera=SMLMSim.IdealCamera(; ypixels=32, xpixels=64, pixelsize=0.1)\n    ) \n\nout = render_blobs(smld_noisy; zoom = 20)\nsave(\"nmer2d.png\", out) # hide","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"<img src=\"nmer2d.png\" alt=\"nmer2d.png\" width=\"600\"/>","category":"page"},{"location":"blob_rendering/#Rendering-3D-Images","page":"Blob Rendering","title":"Rendering 3D Images","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"3D SMLM images will render with a rainbow colormap by default. ","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"using SMLMVis\nusing SMLMSim\nusing Images\n\nsmld_true, smld_model, smld_noisy = SMLMSim.sim(;\n    ρ=10,\n    σ_PSF=[0.13, 0.13, 0.3],  \n    minphotons=50,\n    ndatasets=10,\n    nframes=1000,\n    framerate=50.0, \n    pattern=SMLMSim.Nmer3D(),\n    molecule=SMLMSim.GenericFluor(; q=[0 50; 1e-2 0]), #1/s \n    camera=SMLMSim.IdealCamera(; ypixels=32, xpixels=64, pixelsize=0.1)\n    ) \n\nout = render_blobs(smld_noisy; zoom = 20)\nsave(\"nmer3d.png\", out) # hide","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"<img src=\"nmer3d.png\" alt=\"nmer3d.png\" width=\"600\"/>","category":"page"},{"location":"blob_rendering/#API","page":"Blob Rendering","title":"API","text":"","category":"section"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"Modules = [GaussRender]","category":"page"},{"location":"blob_rendering/","page":"Blob Rendering","title":"Blob Rendering","text":"Modules = [GaussRender]","category":"page"},{"location":"blob_rendering/#SMLMVis.GaussRender.blob!","page":"Blob Rendering","title":"SMLMVis.GaussRender.blob!","text":"blob!(roi::OffsetArray, x::Real, y::Real, σ_x::Real, σ_y::Real, normalization::Symbol)\n\nPopulate the roi array with a 2D Gaussian blob centered at (x, y) with standard deviations σ_x and σ_y.\n\nArguments\n\nroi::OffsetArray{Float32,2}: The 2D array to populate with the Gaussian blob.\nx::Real: The x-coordinate of the center of the Gaussian blob.\ny::Real: The y-coordinate of the center of the Gaussian blob.\nσ_x::Real: The standard deviation of the Gaussian blob in the x-direction.\nσ_y::Real: The standard deviation of the Gaussian blob in the y-direction.\nnormalization::Symbol: The type of normalization to apply to the Gaussian blob. Valid options are :integral (normalize the blob so that its integral is 1) and :maximum (normalize the blob so that its maximum value is 1).\nzoom::Int: The zoom factor to apply to the Gaussian blob.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"blob_rendering/#SMLMVis.GaussRender.calc_range-Tuple{Real, Real, Int64, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Int64}","page":"Blob Rendering","title":"SMLMVis.GaussRender.calc_range","text":"calc_range(x::Real, y::Real, box_size::Int, x_range::Tuple{Int,Int}, y_range::Tuple{Int,Int})\n\nCalculate the starting x- and y-coordinates of a box centered at (x, y) with a given size, within the specified x- and y-ranges.\n\nArguments\n\nx::Real: The x-coordinate of the center of the box.\ny::Real: The y-coordinate of the center of the box.\nbox_size::Int: The size of the box.\nx_range::Tuple{Int,Int}: The range of valid x-coordinates for the box.\ny_range::Tuple{Int,Int}: The range of valid y-coordinates for the box.\nzoom::Int: The zoom factor to apply to the box.\n\nReturns\n\ny_range_roi::UnitRange{Int}: The range of y-coordinates for the box.\nx_range_roi::UnitRange{Int}: The range of x-coordinates for the box.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.combine_rois-Tuple{Vector{<:OffsetArrays.OffsetMatrix{Float32, AA} where AA<:AbstractMatrix{Float32}}, Tuple{Int64, Int64}, Tuple{Int64, Int64}, ColorSchemes.ColorScheme}","page":"Blob Rendering","title":"SMLMVis.GaussRender.combine_rois","text":"combine_rois(rois::Vector{<:OffsetArray}, x_range::Tuple{Int,Int}, y_range::Tuple{Int,Int};\ncolormap::Union{Nothing,Symbol}=nothing,\nz::Union{Nothing,Vector{<:Real}}=nothing,\nz_range::Union{Nothing,Tuple{Real,Real}}=nothing\n)\n\nCombine a vector of 2D arrays into a single image, with optional colorization based on a vector of values.\n\nArguments\n\nrois::Vector{<:OffsetArray{Float32,2}}: A vector of 2D arrays to combine into a single image.\nx_range::Tuple{Int,Int}: The range of valid x-coordinates for the final image.\ny_range::Tuple{Int,Int}: The range of valid y-coordinates for the final image.\ncmap::ColorScheme: The ColorSchemes colormap to use for colorizing the image. Valid options are :viridis, :plasma, :inferno, :magma, :cividis, :rainbow_bgyr_35_85_c72_n256, :hot, :cool, :spring, :summer, :autumn, :winter, :bone, :copper, :pink, :gray, :binary, :gist_earth, :terrain, :ocean, :jet, :nipy_spectral, :gist_ncar, :gist_rainbow, :hsv, :flag, :prism, :flag_r, :prism_r, :rainbow, :rainbow_r, :seismic, :seismic_r, :brg, :brg_r, :bwr, :bwr_r, :coolwarm, :coolwarm_r, :PiYG, :PiYG_r, :PRGn, :PRGn_r, :PuOr, :PuOr_r, :RdBu, :RdBu_r, :RdGy, :RdGy_r, :RdYlBu, :RdYlBu_r, :RdYlGn, :RdYlGn_r, :Spectral, :Spectral_r, :PuBu, :PuBu_r, :BuPu, :BuPu_r, :YlGn, :YlGn_r, :YlGnBu, :YlGnBu_r, :GnBu, :GnBu_r, :PuRd, :PuRd_r, :OrRd, :OrRd_r, :YlOrBr, :YlOrBr_r, :YlOrRd, :YlOrRd_r, :Reds, :Reds_r, :Greens, :Greens_r, :Blues, :Blues_r, :Purples, :Purples_r, :Oranges, :Oranges_r, :Greys, :Greys_r, :Pastel1, :Pastel1_r, :Pastel2, :Pastel2_r, :Set1, :Set1_r, :Set2, :Set2_r, :Set3, :Set3_r, :tab10, :tab10_r, :tab20, :tab20_r, :tab20b, :tab20b_r, :tab20c, :tab20c_r.\nz::Union{Nothing,Vector{<:Real}}=nothing: A vector of values to use for colorizing the image. If nothing, the image will be colorized based on intensity.\nz_range::Union{Nothing,Tuple{Real,Real}}=nothing: The range of values to use for colorizing the image. If nothing, the range will be determined automatically from the values in z.\npercentile_cutoff::Real=0.99: The percentile cutoff for range scaling for intensity scaling.\n\nReturns\n\nfinal_image::OffsetArray: The combined image as a 2D array of RGB values.\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.render_blobs-Tuple{SMLMData.SMLD2D}","page":"Blob Rendering","title":"SMLMVis.GaussRender.render_blobs","text":"renderblobs(smld::SMLMData.SMLD2D;      normalization::Symbol=:integral,     nsigmas::Real=3,     colormap::Symbol=:hot     )\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.render_blobs-Tuple{SMLMData.SMLD3D}","page":"Blob Rendering","title":"SMLMVis.GaussRender.render_blobs","text":"renderblobs(smld::SMLMData.SMLD3D;      normalization::Symbol=:integral,     nsigmas::Real=3,     colormap::Symbol=:rainbowbgyr3585c72n256,     zrange::Union{Nothing,Tuple{Real,Real}}=nothing     )\n\n\n\n\n\n","category":"method"},{"location":"blob_rendering/#SMLMVis.GaussRender.render_blobs-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"Blob Rendering","title":"SMLMVis.GaussRender.render_blobs","text":"renderblobs(     xrange::Tuple{Int,Int},     yrange::Tuple{Int,Int},     x::Vector{<:Real},     y::Vector{<:Real},     σx::Vector{<:Real},     σy::Vector{<:Real};     normalization::Symbol=:integral,     nsigmas::Real=3,     colormap::Union{Nothing,Symbol}=nothing,     z::Union{Nothing,Vector{<:Real}}=nothing,     zrange::Union{Nothing,Tuple{Real,Real}}=nothing,     zoom::Int=1,     percentilecutoff::Real=0.99     )\n\nRender a stack of 2D Gaussian blobs as a single image.\n\nArguments\n\nx_range::Tuple{Int,Int}: The range of valid x-coordinates for the final image.\ny_range::Tuple{Int,Int}: The range of valid y-coordinates for the final image.\nx::Vector{<:Real}: A vector of x-coordinates for the centers of the Gaussian blobs.\ny::Vector{<:Real}: A vector of y-coordinates for the centers of the Gaussian blobs.\nσ_x::Vector{<:Real}: A vector of standard deviations for the Gaussian blobs in the x-direction.\nσ_y::Vector{<:Real}: A vector of standard deviations for the Gaussian blobs in the y-direction.\nnormalization::Symbol=:integral: The type of normalization to apply to the Gaussian blobs. Valid options are :integral (normalize the blobs so that their integrals are 1) and :maximum (normalize the blobs so that their maximum values are 1).\nn_sigmas::Real=3: The number of standard deviations to use for calculating the size of the region of interest (ROI) around each Gaussian blob.\ncolormap::Union{Nothing,Symbol}=nothing: The name of the colormap to use for colorizing the image. Valid options are :viridis, :plasma, :inferno, :magma, :cividis, :rainbow_bgyr_35_85_c72_n256, :hot, :cool, :spring, :summer, :autumn, :winter, :bone, :copper, :pink, :gray, :binary, :gist_earth, :terrain, :ocean, :jet, :nipy_spectral, :gist_ncar, :gist_rainbow, :hsv, :flag, :prism, :flag_r, :prism_r, :rainbow, :rainbow_r, :seismic, :seismic_r, :brg, :brg_r, :bwr, :bwr_r, :coolwarm, :coolwarm_r, :PiYG, :PiYG_r, :PRGn, :PRGn_r, :PuOr, :PuOr_r, :RdBu, :RdBu_r, :RdGy, :RdGy_r, :RdYlBu, :RdYlBu_r, :RdYlGn, :RdYlGn_r, :Spectral, :Spectral_r, :PuBu, :PuBu_r, :BuPu, :BuPu_r, :YlGn, :YlGn_r, :YlGnBu, :YlGnBu_r, :GnBu, :GnBu_r, :PuRd, :PuRd_r, :OrRd, :OrRd_r, :YlOrBr, :YlOrBr_r, :YlOrRd, :YlOrRd_r, :Reds, :Reds_r, :Greens, :Greens_r, :Blues, :Blues_r, :Purples, :Purples_r, :Oranges, :Oranges_r, :Greys, :Greys_r, :Pastel1, :Pastel1_r, :Pastel2, :Pastel2_r, :Set1, :Set1_r, :Set2, :Set2_r, :Set3, :Set3_r, :tab10, :tab10_r, :tab20, :tab20_r, :tab20b, :tab20b_r, :tab20c, :tab20c_r.\nz::Union{Nothing,Vector{<:Real}}=nothing: A vector of values to use for colorizing the image. If nothing, the image will be colorized based on intensity.\nz_range::Union{Nothing,Tuple{Real,Real}}=nothing: The range of values to use for colorizing the image. If nothing, the range will be determined automatically from the values in z.\nzoom::Int=1: The zoom factor to apply to the image.\npercentile_cutoff::Real=0.99: The percentile cutoff for intensity scaling.\n\nReturns\n\nfinal_image::OffsetArray: The rendered image as a 2D array of RGB values.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SMLMVis","category":"page"},{"location":"#SMLMVis","page":"Home","title":"SMLMVis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SMLMVis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SMLMVis]","category":"page"}]
}
